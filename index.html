<!DOCTYPE html>
<html>
<head>
    <title>Huffman Coding</title>
    <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<body>
    <div class="container">
        <h1>Huffman Coding</h1>
        
        <h2>About Huffman Coding</h2>
        <p>Huffman coding is a lossless data compression algorithm. The idea is to assign variable-length codes to input characters, lengths of the assigned codes are based on the frequencies of corresponding characters.</p>
        <p>Huffman Coding is a lossless data compression algorithm that uses variable-length codes for encoding characters, ensuring that more frequent characters use shorter codes and less frequent ones use longer codes. It is a greedy algorithm that builds an optimal prefix tree for encoding.</p>
        
        <h2>Example</h2>
        <div class="example">
            <p>Consider the following character frequencies:</p>
            <ul>
                <li>A: 5</li>
                <li>B: 9</li>
                <li>C: 12</li>
                <li>D: 13</li>
                <li>E: 16</li>
                <li>F: 45</li>
            </ul>
            <p>The Huffman Tree is built as follows:</p>
            <ol>
                <li>Combine the two lowest frequency nodes (A and B) into a new node.</li>
                <li>Repeat the process until only one node remains (the root of the tree).</li>
                <li>Assign binary codes (0,1) to traverse the tree.</li>
            </ol>
            <p class="animated-step">Final Huffman Codes:</p>
            <ul>
                <li>A: 1100</li>
                <li>B: 1101</li>
                <li>C: 100</li>
                <li>D: 101</li>
                <li>E: 111</li>
                <li>F: 0</li>
            </ul>
        </div>
        
        <h2>Advantages</h2>
        <div class="advantages">
            <ul>
                <li>Efficient compression: Reduces file size significantly.</li>
                <li>Lossless compression: No data is lost.</li>
                <li>Widely used in text and image compression.</li>
            </ul>
        </div>
        
        <h2>Disadvantages</h2>
        <div class="disadvantages">
            <ul>
                <li>Computational overhead: Tree construction can be time-consuming.</li>
                <li>Decoding complexity: Requires traversal of the Huffman tree.</li>
                <li>Not suitable for small datasets: Works best with large input files.</li>
            </ul>
        </div>

        <h2>Time Complexity Analysis</h2>
        <div class="time-complexity">
            <ul>
                <li>Best Case: O(n) - When input characters have equal frequencies and an optimal balanced tree is formed.</li>
                <li>Average Case: O(n log n) - Due to the priority queue operations while building the Huffman tree.</li>
                <li>Worst Case: O(n log n) - When input characters have highly skewed frequencies requiring multiple merges.</li>
            </ul>
        </div>
    </div>
</body>
</html>
